###############################################################################################################################################
############################################## Импортируем необходимые модули и данные ########################################################
###############################################################################################################################################

# Для работы с Deep Learning
import torch.nn as nn

###############################################################################################################################################
############################################## Создаем объект класса ##########################################################################
###############################################################################################################################################

class Autoencoder(nn.Module):
    def __init__(self):
        """
        Инициализации класса. 
        Вход: 
                нет.
        Выход: 
                нет.
        """
        super(Autoencoder, self).__init__()
        self.encoder = nn.Sequential(
            nn.Linear(1400, 512)
            ,nn.ReLU(True)
            ,nn.Linear(512, 128)
            ,nn.ReLU(True)
        )
        self.decoder = nn.Sequential(
            nn.Linear(128, 512)
            ,nn.ReLU(True)
            ,nn.Linear(512, 1400)
        )
        
    def forward(self, X, batch_size_current):
        """
        Сжатие смысла текста.
        Вход: 
                X(tensor): тензор вошедшей строки.   
                batch_size_current(int): размерность пачки.                
        Выход: 
                (torch.Tensor): тензор. 
        """
        # input: [48, 1400]    
        # output [48, 1400]
              
        X = self.encoder(X)
        X = self.decoder(X)
        return X